"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Container = void 0;
const store_1 = require("./store");
const errors_1 = require("./errors");
class Container {
    /**
     * Register new or replace providers
     */
    static provide(providers) {
        providers.forEach(provider => {
            if (provider.useClass) {
                return this.registerClassProvider(provider);
            }
            if (provider.useFactory) {
                return this.registerFactoryProvider(provider);
            }
            if (provider.useValue) {
                return this.registerValueProvider(provider);
            }
        });
    }
    /**
     * Get instance of injectable
     */
    static get(injectable) {
        const provider = store_1.Store.findProvider(injectable);
        if (!provider) {
            throw new errors_1.MissingProviderError(injectable);
        }
        return this.resolveProvider(provider);
    }
    /**
     * Resolve provider
     */
    static resolveProvider(provider, requesters = []) {
        return __awaiter(this, void 0, void 0, function* () {
            if (provider.value) {
                return provider.value;
            }
            const _requesters = requesters.concat([provider]);
            const deps = provider.deps.map((dep) => {
                const requesterProvider = _requesters.find((requester) => requester.id === dep.id);
                if (requesterProvider) {
                    throw new errors_1.RecursiveProviderError(_requesters, requesterProvider);
                }
                const depService = store_1.Store.findProvider(dep.id);
                if (!depService && !dep.optional) {
                    throw new errors_1.MissingProviderError(provider, dep);
                }
                if (!depService && dep.optional) {
                    return null;
                }
                return this.resolveProvider(depService, _requesters);
            });
            const resolvedDeps = yield Promise.all(deps);
            return provider.factory ? provider.factory(...resolvedDeps) : new provider.type(...resolvedDeps);
        });
    }
    /**
     * Register class provider
     */
    static registerClassProvider(provider) {
        const id = store_1.Store.providerId(provider.provide);
        const classProvider = store_1.Store.findProvider(provider.useClass);
        const deps = classProvider ? classProvider.deps : (provider.deps || [])
            .map((dep) => ({ id: store_1.Store.providerId(dep) }));
        store_1.Store.replaceProvider(provider.provide, { id, deps, type: provider.useClass });
    }
    /**
     * Register factory provider
     */
    static registerFactoryProvider(provider) {
        const id = store_1.Store.providerId(provider.provide);
        const factory = provider.useFactory;
        const deps = (provider.deps || [])
            .map((dep) => ({ id: store_1.Store.providerId(dep) }));
        store_1.Store.replaceProvider(provider.provide, { id, factory, deps });
    }
    /**
     * Register value provider
     */
    static registerValueProvider(provider) {
        const id = store_1.Store.providerId(provider.provide);
        const value = provider.useValue;
        store_1.Store.replaceProvider(provider.provide, { id, value });
    }
}
exports.Container = Container;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGFpbmVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NvbnRhaW5lci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFXQSxtQ0FBZ0M7QUFDaEMscUNBQXdFO0FBRXhFLE1BQWEsU0FBUztJQUVwQjs7T0FFRztJQUNILE1BQU0sQ0FBQyxPQUFPLENBQUMsU0FBcUI7UUFDbEMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsRUFBRTtZQUMzQixJQUFLLFFBQTBCLENBQUMsUUFBUSxFQUFFO2dCQUN4QyxPQUFPLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxRQUF5QixDQUFDLENBQUM7YUFDOUQ7WUFFRCxJQUFLLFFBQTRCLENBQUMsVUFBVSxFQUFFO2dCQUM1QyxPQUFPLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxRQUEyQixDQUFDLENBQUM7YUFDbEU7WUFFRCxJQUFLLFFBQTBCLENBQUMsUUFBUSxFQUFFO2dCQUN4QyxPQUFPLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxRQUF5QixDQUFDLENBQUM7YUFDOUQ7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7T0FFRztJQUNILE1BQU0sQ0FBQyxHQUFHLENBQUksVUFBc0I7UUFDbEMsTUFBTSxRQUFRLEdBQWtCLGFBQUssQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFL0QsSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNiLE1BQU0sSUFBSSw2QkFBb0IsQ0FBQyxVQUFVLENBQUMsQ0FBQztTQUM1QztRQUVELE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBSSxRQUFRLENBQUMsQ0FBQztJQUMzQyxDQUFDO0lBRUQ7O09BRUc7SUFDSyxNQUFNLENBQU8sZUFBZSxDQUFJLFFBQXVCLEVBQUUsYUFBOEIsRUFBRTs7WUFDL0YsSUFBSSxRQUFRLENBQUMsS0FBSyxFQUFFO2dCQUNsQixPQUFPLFFBQVEsQ0FBQyxLQUFLLENBQUM7YUFDdkI7WUFF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QUMsQ0FBQztJQUNqRSxDQUFDO0lBRUQ7O09BRUc7SUFDSyxNQUFNLENBQUMscUJBQXFCLENBQUMsUUFBdUI7UUFDMUQsTUFBTSxFQUFFLEdBQWlCLGFBQUssQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzVELE1BQU0sS0FBSyxHQUFRLFFBQVEsQ0FBQyxRQUFRLENBQUM7UUFFckMsYUFBSyxDQUFDLGVBQWUsQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7SUFDekQsQ0FBQztDQUNGO0FBdkdELDhCQXVHQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEluamVjdGFibGVJZCxcbiAgUHJvdmlkZXIsXG4gIFN0b3JlUHJvdmlkZXIsXG4gIENsYXNzUHJvdmlkZXIsXG4gIEZhY3RvcnlQcm92aWRlcixcbiAgVmFsdWVQcm92aWRlcixcbiAgRGVwZW5kZW5jeSxcbiAgSW5qZWN0YWJsZSxcbiAgRmFjdG9yeSxcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBTdG9yZSB9IGZyb20gJy4vc3RvcmUnO1xuaW1wb3J0IHsgTWlzc2luZ1Byb3ZpZGVyRXJyb3IsIFJlY3Vyc2l2ZVByb3ZpZGVyRXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5cbmV4cG9ydCBjbGFzcyBDb250YWluZXIge1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBuZXcgb3IgcmVwbGFjZSBwcm92aWRlcnNcbiAgICovXG4gIHN0YXRpYyBwcm92aWRlKHByb3ZpZGVyczogUHJvdmlkZXJbXSkge1xuICAgIHByb3ZpZGVycy5mb3JFYWNoKHByb3ZpZGVyID0+IHtcbiAgICAgIGlmICgocHJvdmlkZXIgYXMgQ2xhc3NQcm92aWRlcikudXNlQ2xhc3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJDbGFzc1Byb3ZpZGVyKHByb3ZpZGVyIGFzIENsYXNzUHJvdmlkZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoKHByb3ZpZGVyIGFzIEZhY3RvcnlQcm92aWRlcikudXNlRmFjdG9yeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RlckZhY3RvcnlQcm92aWRlcihwcm92aWRlciBhcyBGYWN0b3J5UHJvdmlkZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoKHByb3ZpZGVyIGFzIFZhbHVlUHJvdmlkZXIpLnVzZVZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyVmFsdWVQcm92aWRlcihwcm92aWRlciBhcyBWYWx1ZVByb3ZpZGVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgaW5zdGFuY2Ugb2YgaW5qZWN0YWJsZVxuICAgKi9cbiAgc3RhdGljIGdldDxUPihpbmplY3RhYmxlOiBJbmplY3RhYmxlKTogUHJvbWlzZTxUPiB7XG4gICAgY29uc3QgcHJvdmlkZXI6IFN0b3JlUHJvdmlkZXIgPSBTdG9yZS5maW5kUHJvdmlkZXIoaW5qZWN0YWJsZSk7XG5cbiAgICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgTWlzc2luZ1Byb3ZpZGVyRXJyb3IoaW5qZWN0YWJsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZVByb3ZpZGVyPFQ+KHByb3ZpZGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlIHByb3ZpZGVyXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBhc3luYyByZXNvbHZlUHJvdmlkZXI8VD4ocHJvdmlkZXI6IFN0b3JlUHJvdmlkZXIsIHJlcXVlc3RlcnM6IFN0b3JlUHJvdmlkZXJbXSA9IFtdKTogUHJvbWlzZTxUPiB7XG4gICAgaWYgKHByb3ZpZGVyLnZhbHVlKSB7XG4gICAgICByZXR1cm4gcHJvdmlkZXIudmFsdWU7XG4gICAgfVxuXG4gICAgY29uc3QgX3JlcXVlc3RlcnMgPSByZXF1ZXN0ZXJzLmNvbmNhdChbcHJvdmlkZXJdKTtcblxuICAgIGNvbnN0IGRlcHMgPSBwcm92aWRlci5kZXBzLm1hcCgoZGVwOiBEZXBlbmRlbmN5KSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0ZXJQcm92aWRlcjogU3RvcmVQcm92aWRlciA9XG4gICAgICAgIF9yZXF1ZXN0ZXJzLmZpbmQoKHJlcXVlc3RlcjogU3RvcmVQcm92aWRlcikgPT4gcmVxdWVzdGVyLmlkID09PSBkZXAuaWQpO1xuXG4gICAgICBpZiAocmVxdWVzdGVyUHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlY3Vyc2l2ZVByb3ZpZGVyRXJyb3IoX3JlcXVlc3RlcnMsIHJlcXVlc3RlclByb3ZpZGVyKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGVwU2VydmljZTogU3RvcmVQcm92aWRlciA9IFN0b3JlLmZpbmRQcm92aWRlcihkZXAuaWQpO1xuXG4gICAgICBpZiAoIWRlcFNlcnZpY2UgJiYgIWRlcC5vcHRpb25hbCkge1xuICAgICAgICB0aHJvdyBuZXcgTWlzc2luZ1Byb3ZpZGVyRXJyb3IocHJvdmlkZXIsIGRlcCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZGVwU2VydmljZSAmJiBkZXAub3B0aW9uYWwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJlc29sdmVQcm92aWRlcihkZXBTZXJ2aWNlLCBfcmVxdWVzdGVycyk7XG4gICAgfSk7XG5cbiAgICBjb25zdCByZXNvbHZlZERlcHMgPSBhd2FpdCBQcm9taXNlLmFsbChkZXBzKTtcblxuICAgIHJldHVybiBwcm92aWRlci5mYWN0b3J5ID8gcHJvdmlkZXIuZmFjdG9yeSguLi5yZXNvbHZlZERlcHMpIDogbmV3IHByb3ZpZGVyLnR5cGUoLi4ucmVzb2x2ZWREZXBzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBjbGFzcyBwcm92aWRlclxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgcmVnaXN0ZXJDbGFzc1Byb3ZpZGVyKHByb3ZpZGVyOiBDbGFzc1Byb3ZpZGVyKTogdm9pZCB7XG4gICAgY29uc3QgaWQ6IEluamVjdGFibGVJZCA9IFN0b3JlLnByb3ZpZGVySWQocHJvdmlkZXIucHJvdmlkZSk7XG4gICAgY29uc3QgY2xhc3NQcm92aWRlcjogU3RvcmVQcm92aWRlciA9IFN0b3JlLmZpbmRQcm92aWRlcihwcm92aWRlci51c2VDbGFzcyk7XG4gICAgY29uc3QgZGVwczogRGVwZW5kZW5jeVtdID0gY2xhc3NQcm92aWRlciA/IGNsYXNzUHJvdmlkZXIuZGVwcyA6IChwcm92aWRlci5kZXBzIHx8IFtdKVxuICAgICAgLm1hcCgoZGVwOiBJbmplY3RhYmxlKSA9PiAoeyBpZDogU3RvcmUucHJvdmlkZXJJZChkZXApIH0pKTtcblxuICAgIFN0b3JlLnJlcGxhY2VQcm92aWRlcihwcm92aWRlci5wcm92aWRlLCB7IGlkLCBkZXBzLCB0eXBlOiBwcm92aWRlci51c2VDbGFzcyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBmYWN0b3J5IHByb3ZpZGVyXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyByZWdpc3RlckZhY3RvcnlQcm92aWRlcihwcm92aWRlcjogRmFjdG9yeVByb3ZpZGVyKTogdm9pZCB7XG4gICAgY29uc3QgaWQ6IEluamVjdGFibGVJZCA9IFN0b3JlLnByb3ZpZGVySWQocHJvdmlkZXIucHJvdmlkZSk7XG4gICAgY29uc3QgZmFjdG9yeTogRmFjdG9yeSA9IHByb3ZpZGVyLnVzZUZhY3Rvcnk7XG4gICAgY29uc3QgZGVwczogRGVwZW5kZW5jeVtdID0gKHByb3ZpZGVyLmRlcHMgfHwgW10pXG4gICAgICAubWFwKChkZXA6IEluamVjdGFibGUpID0+ICh7IGlkOiBTdG9yZS5wcm92aWRlcklkKGRlcCkgfSkpO1xuXG4gICAgU3RvcmUucmVwbGFjZVByb3ZpZGVyKHByb3ZpZGVyLnByb3ZpZGUsIHsgaWQsIGZhY3RvcnksIGRlcHMgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgdmFsdWUgcHJvdmlkZXJcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIHJlZ2lzdGVyVmFsdWVQcm92aWRlcihwcm92aWRlcjogVmFsdWVQcm92aWRlcik6IHZvaWQge1xuICAgIGNvbnN0IGlkOiBJbmplY3RhYmxlSWQgPSBTdG9yZS5wcm92aWRlcklkKHByb3ZpZGVyLnByb3ZpZGUpO1xuICAgIGNvbnN0IHZhbHVlOiBhbnkgPSBwcm92aWRlci51c2VWYWx1ZTtcblxuICAgIFN0b3JlLnJlcGxhY2VQcm92aWRlcihwcm92aWRlci5wcm92aWRlLCB7IGlkLCB2YWx1ZSB9KTtcbiAgfVxufVxuIl19