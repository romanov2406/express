(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "class-transformer", "class-validator", "reflect-metadata"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const class_transformer_1 = require("class-transformer");
    const class_validator_1 = require("class-validator");
    require("reflect-metadata");
    class ValidatorError extends Error {
        constructor(validationErrors) {
            super("Validation Error");
            this.validationErrors = validationErrors;
            Object.setPrototypeOf(this, ValidatorError.prototype);
        }
    }
    exports.ValidatorError = ValidatorError;
    function Validate(validatorOptions) {
        return (target, key, descriptor) => {
            const originalMethod = descriptor.value;
            const indices = Reflect.getMetadata(`validate_${key}_parameters`, target, key);
            const types = Reflect.getMetadata("design:paramtypes", target, key);
            const targets = Reflect.getMetadata(`validate_${key}_targets`, target, key) || {};
            descriptor.value = function (...args) {
                const errors = [];
                if (Array.isArray(indices)) {
                    for (let i = 0; i < args.length; i++) {
                        if (indices.indexOf(i) !== -1) {
                            let value = args[i];
                            let validatorClass = types[i];
                            if (targets && targets[i]) {
                                value = getNestedObjectProperty(value, targets[i].targetKey);
                                validatorClass = targets[i].validatorClass;
                                if (!value) {
                                    const error = new class_validator_1.ValidationError();
                                    error.constraints = {
                                        isDefined: `property ${targets[i].targetKey} is missing`,
                                    };
                                    throw new ValidatorError([error]);
                                }
                                if (Array.isArray(types[i].prototype)) {
                                    if (!Array.isArray(value)) {
                                        const error = new class_validator_1.ValidationError();
                                        error.constraints = {
                                            isArray: "input param must be array",
                                        };
                                        throw new ValidatorError([error]);
                                    }
                                    for (const argument of value) {
                                        const paramError = getValidationErrors(validatorClass, argument, validatorOptions);
                                        if (paramError.length) {
                                            errors.push(...paramError);
                                        }
                                    }
                                }
                            }
                            const paramErrors = getValidationErrors(validatorClass, value, validatorOptions);
                            if (paramErrors.length) {
                                errors.push(...paramErrors);
                            }
                        }
                    }
                    if (errors.length) {
                        throw new ValidatorError(errors);
                    }
                    return originalMethod.apply(this, args);
                }
            };
            return descriptor;
        };
    }
    exports.Validate = Validate;
    /**
     * When provided the validatorClass validation will be performed on the provided key or root object
     * instead of argument itself. useful for when the validator data is located in a nested object.
     *
     * @param validatorClass - the validator class to use instead of the inferred ts type
     * @param targetKey -
     * @returns {(target: any, key: string, index) => void}
     */
    function Validator(validatorClass, targetKey) {
        return (target, key, index) => {
            const indices = Reflect.getMetadata(`validate_${key}_parameters`, target, key) || [];
            if (validatorClass !== undefined) {
                const targets = Reflect.getMetadata(`validate_${key}_targets`, target, key) || {};
                console.log(targets);
                targets[index] = {
                    targetKey: targetKey || "",
                    validatorClass,
                };
                Reflect.defineMetadata(`validate_${key}_targets`, targets, target, key);
            }
            indices.push(index);
            Reflect.defineMetadata(`validate_${key}_parameters`, indices, target, key);
        };
    }
    exports.Validator = Validator;
    function getValidationErrors(validatorClass, val, validatorOptions) {
        const data = class_transformer_1.plainToClass(validatorClass, val);
        const validator = new class_validator_1.Validator();
        return validator.validateSync(data, validatorOptions);
    }
    exports.getValidationErrors = getValidationErrors;
    function getNestedObjectProperty(object, path) {
        let value = object;
        if (!path) {
            return value;
        }
        const list = path.split(".");
        for (let i = 0; i < list.length; i++) {
            value = value[list[i]];
            if (value === undefined) {
                return undefined;
            }
        }
        return value;
    }
    exports.getNestedObjectProperty = getNestedObjectProperty;
});
//# sourceMappingURL=lib.js.map